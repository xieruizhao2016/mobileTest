//
//  AsyncFileReader.swift
//  mobileTest
//
//  Created by ruizhao_xie on 12/19/24.
//

import Foundation

// MARK: - ÂºÇÊ≠•Êñá‰ª∂ËØªÂèñÂçèËÆÆ
protocol AsyncFileReaderProtocol {
    /// ÂºÇÊ≠•ËØªÂèñÊú¨Âú∞Êñá‰ª∂
    /// - Parameters:
    ///   - fileName: Êñá‰ª∂ÂêçÔºà‰∏çÂåÖÂê´Êâ©Â±ïÂêçÔºâ
    ///   - fileExtension: Êñá‰ª∂Êâ©Â±ïÂêç
    ///   - bundle: BundleÂÆû‰æãÔºåÈªòËÆ§‰∏∫main
    /// - Returns: Êñá‰ª∂Êï∞ÊçÆ
    /// - Throws: BookingDataError
    func readLocalFile(fileName: String, fileExtension: String, bundle: Bundle) async throws -> Data
    
    /// ÂºÇÊ≠•ËØªÂèñËøúÁ®ãÊñá‰ª∂
    /// - Parameters:
    ///   - url: ËøúÁ®ãÊñá‰ª∂URL
    ///   - timeout: ËØ∑Ê±ÇË∂ÖÊó∂Êó∂Èó¥
    /// - Returns: Êñá‰ª∂Êï∞ÊçÆ
    /// - Throws: BookingDataError
    func readRemoteFile(url: URL, timeout: TimeInterval) async throws -> Data
    
    /// ÂºÇÊ≠•ËØªÂèñÊñá‰ª∂ÔºàËá™Âä®Ê£ÄÊµãÊú¨Âú∞ÊàñËøúÁ®ãÔºâ
    /// - Parameters:
    ///   - source: Êñá‰ª∂Ê∫êÔºàÊú¨Âú∞Êñá‰ª∂ÂêçÊàñËøúÁ®ãURLÔºâ
    ///   - fileExtension: Êñá‰ª∂Êâ©Â±ïÂêçÔºà‰ªÖÁî®‰∫éÊú¨Âú∞Êñá‰ª∂Ôºâ
    ///   - timeout: ËØ∑Ê±ÇË∂ÖÊó∂Êó∂Èó¥Ôºà‰ªÖÁî®‰∫éËøúÁ®ãÊñá‰ª∂Ôºâ
    /// - Returns: Êñá‰ª∂Êï∞ÊçÆ
    /// - Throws: BookingDataError
    func readFile(source: String, fileExtension: String?, timeout: TimeInterval?) async throws -> Data
    
    /// Â∏¶ËøõÂ∫¶ÂõûË∞ÉÁöÑÂºÇÊ≠•Êñá‰ª∂ËØªÂèñ
    /// - Parameters:
    ///   - source: Êñá‰ª∂Ê∫ê
    ///   - fileExtension: Êñá‰ª∂Êâ©Â±ïÂêç
    ///   - timeout: Ë∂ÖÊó∂Êó∂Èó¥
    ///   - progressCallback: ËøõÂ∫¶ÂõûË∞É
    /// - Returns: Êñá‰ª∂Êï∞ÊçÆ
    /// - Throws: BookingDataError
    func readFileWithProgress(
        source: String,
        fileExtension: String?,
        timeout: TimeInterval?,
        progressCallback: @escaping (Double) -> Void
    ) async throws -> Data
    
    /// ÂºÇÊ≠•ËØªÂèñÂéãÁº©Êñá‰ª∂
    /// - Parameters:
    ///   - fileName: Êñá‰ª∂ÂêçÔºà‰∏çÂåÖÂê´Êâ©Â±ïÂêçÔºâ
    ///   - fileExtension: Êñá‰ª∂Êâ©Â±ïÂêç
    ///   - bundle: BundleÂÆû‰æã
    ///   - autoDecompress: ÊòØÂê¶Ëá™Âä®Ëß£ÂéãÁº©
    /// - Returns: Êñá‰ª∂Êï∞ÊçÆÔºàÂ¶ÇÊûúautoDecompress‰∏∫trueÔºåËøîÂõûËß£ÂéãÁº©ÂêéÁöÑÊï∞ÊçÆÔºâ
    /// - Throws: BookingDataError
    func readCompressedFile(
        fileName: String,
        fileExtension: String,
        bundle: Bundle,
        autoDecompress: Bool
    ) async throws -> Data
    
    /// ÂºÇÊ≠•ËØªÂèñËøúÁ®ãÂéãÁº©Êñá‰ª∂
    /// - Parameters:
    ///   - url: ËøúÁ®ãÊñá‰ª∂URL
    ///   - timeout: ËØ∑Ê±ÇË∂ÖÊó∂Êó∂Èó¥
    ///   - autoDecompress: ÊòØÂê¶Ëá™Âä®Ëß£ÂéãÁº©
    /// - Returns: Êñá‰ª∂Êï∞ÊçÆÔºàÂ¶ÇÊûúautoDecompress‰∏∫trueÔºåËøîÂõûËß£ÂéãÁº©ÂêéÁöÑÊï∞ÊçÆÔºâ
    /// - Throws: BookingDataError
    func readRemoteCompressedFile(
        url: URL,
        timeout: TimeInterval,
        autoDecompress: Bool
    ) async throws -> Data
    
    /// Ê£ÄÊµãÊñá‰ª∂ÊòØÂê¶‰∏∫ÂéãÁº©Ê†ºÂºè
    /// - Parameter data: Êñá‰ª∂Êï∞ÊçÆ
    /// - Returns: ÂéãÁº©‰ø°ÊÅØÔºåÂ¶ÇÊûú‰∏çÊòØÂéãÁº©Ê†ºÂºèÂàôËøîÂõûnil
    func detectCompressionFormat(from data: Data) -> CompressionInfo?
}

// MARK: - ÂºÇÊ≠•Êñá‰ª∂ËØªÂèñÂÆûÁé∞
class AsyncFileReader: AsyncFileReaderProtocol {
    
    // MARK: - Â±ûÊÄß
    private let urlSession: URLSession
    private let enableVerboseLogging: Bool
    private let retryManager: RetryManager
    private let compressionManager: CompressionManagerProtocol
    
    // MARK: - ÂàùÂßãÂåñÂô®
    
    /// ‰ΩøÁî®ÈªòËÆ§ÈÖçÁΩÆÂàùÂßãÂåñ
    /// - Parameters:
    ///   - enableVerboseLogging: ÊòØÂê¶ÂêØÁî®ËØ¶ÁªÜÊó•Âøó
    ///   - retryConfiguration: ÈáçËØïÈÖçÁΩÆ
    ///   - compressionManager: ÂéãÁº©ÁÆ°ÁêÜÂô®
    init(enableVerboseLogging: Bool = true, retryConfiguration: RetryConfiguration = .default, compressionManager: CompressionManagerProtocol? = nil) {
        self.enableVerboseLogging = enableVerboseLogging
        self.retryManager = RetryManager(configuration: retryConfiguration, enableVerboseLogging: enableVerboseLogging)
        self.compressionManager = compressionManager ?? CompressionManagerFactory.createDefault(enableVerboseLogging: enableVerboseLogging)
        
        // ÈÖçÁΩÆURLSession
        let config = URLSessionConfiguration.default
        config.timeoutIntervalForRequest = 30.0
        config.timeoutIntervalForResource = 60.0
        config.waitsForConnectivity = true
        self.urlSession = URLSession(configuration: config)
    }
    
    /// ‰ΩøÁî®Ëá™ÂÆö‰πâURLSessionÂàùÂßãÂåñ
    /// - Parameters:
    ///   - urlSession: Ëá™ÂÆö‰πâURLSession
    ///   - enableVerboseLogging: ÊòØÂê¶ÂêØÁî®ËØ¶ÁªÜÊó•Âøó
    ///   - retryConfiguration: ÈáçËØïÈÖçÁΩÆ
    ///   - compressionManager: ÂéãÁº©ÁÆ°ÁêÜÂô®
    init(urlSession: URLSession, enableVerboseLogging: Bool = true, retryConfiguration: RetryConfiguration = .default, compressionManager: CompressionManagerProtocol? = nil) {
        self.urlSession = urlSession
        self.enableVerboseLogging = enableVerboseLogging
        self.retryManager = RetryManager(configuration: retryConfiguration, enableVerboseLogging: enableVerboseLogging)
        self.compressionManager = compressionManager ?? CompressionManagerFactory.createDefault(enableVerboseLogging: enableVerboseLogging)
    }
    
    // MARK: - ÂÖ¨ÂÖ±ÊñπÊ≥ï
    
    /// ÂºÇÊ≠•ËØªÂèñÊú¨Âú∞Êñá‰ª∂
    func readLocalFile(fileName: String, fileExtension: String, bundle: Bundle = .main) async throws -> Data {
        log("üìÅ [AsyncFileReader] ÂºÄÂßãËØªÂèñÊú¨Âú∞Êñá‰ª∂: \(fileName).\(fileExtension)")
        
        guard let fileURL = bundle.url(forResource: fileName, withExtension: fileExtension) else {
            let error = BookingDataError.fileNotFound("Bundle‰∏≠Êâæ‰∏çÂà∞Êñá‰ª∂: \(fileName).\(fileExtension)")
            ErrorHandler.logError(error, context: "AsyncFileReader.readLocalFile", enableVerboseLogging: enableVerboseLogging)
            throw error
        }
        
        return try await retryManager.executeWithRetry {
            try await self.readLocalFileWithFileHandle(url: fileURL)
        }
    }
    
    /// ÂºÇÊ≠•ËØªÂèñËøúÁ®ãÊñá‰ª∂
    func readRemoteFile(url: URL, timeout: TimeInterval = 30.0) async throws -> Data {
        log("üåê [AsyncFileReader] ÂºÄÂßãËØªÂèñËøúÁ®ãÊñá‰ª∂: \(url.absoluteString)")
        
        return try await retryManager.executeWithRetry {
            var request = URLRequest(url: url)
            request.timeoutInterval = timeout
            request.setValue("application/json", forHTTPHeaderField: "Accept")
            request.setValue("mobileTest/1.0", forHTTPHeaderField: "User-Agent")
            
            do {
                let (data, response) = try await self.urlSession.data(for: request)
                
                guard let httpResponse = response as? HTTPURLResponse else {
                    let error = BookingDataError.networkError("Êó†ÊïàÁöÑHTTPÂìçÂ∫î")
                    ErrorHandler.logError(error, context: "AsyncFileReader.readRemoteFile", enableVerboseLogging: self.enableVerboseLogging)
                    throw error
                }
                
                guard httpResponse.statusCode == 200 else {
                    let error = ErrorHandler.handleHTTPStatusCode(httpResponse.statusCode, url: url.absoluteString)
                    ErrorHandler.logError(error, context: "AsyncFileReader.readRemoteFile", enableVerboseLogging: self.enableVerboseLogging)
                    throw error
                }
                
                self.log("‚úÖ [AsyncFileReader] ÊàêÂäüËØªÂèñËøúÁ®ãÊñá‰ª∂ÔºåÂ§ßÂ∞è: \(data.count) Â≠óËäÇ")
                return data
                
            } catch let error as URLError {
                let bookingError = ErrorHandler.handleNetworkError(error, url: url.absoluteString)
                ErrorHandler.logError(bookingError, context: "AsyncFileReader.readRemoteFile", enableVerboseLogging: self.enableVerboseLogging)
                throw bookingError
            } catch let error as BookingDataError {
                ErrorHandler.logError(error, context: "AsyncFileReader.readRemoteFile", enableVerboseLogging: self.enableVerboseLogging)
                throw error
            } catch {
                let bookingError = BookingDataError.networkError("ËØªÂèñÂ§±Ë¥•: \(error.localizedDescription)")
                ErrorHandler.logError(bookingError, context: "AsyncFileReader.readRemoteFile", enableVerboseLogging: self.enableVerboseLogging)
                throw bookingError
            }
        }
    }
    
    /// ÂºÇÊ≠•ËØªÂèñÊñá‰ª∂ÔºàËá™Âä®Ê£ÄÊµãÊú¨Âú∞ÊàñËøúÁ®ãÔºâ
    func readFile(source: String, fileExtension: String? = nil, timeout: TimeInterval? = nil) async throws -> Data {
        // Ê£ÄÊµãÊòØÂê¶‰∏∫URL
        if let url = URL(string: source), url.scheme != nil {
            log("üåê [AsyncFileReader] Ê£ÄÊµãÂà∞ËøúÁ®ãURLÔºå‰ΩøÁî®ÁΩëÁªúËØªÂèñ")
            return try await readRemoteFile(url: url, timeout: timeout ?? 30.0)
        } else {
            log("üìÅ [AsyncFileReader] Ê£ÄÊµãÂà∞Êú¨Âú∞Êñá‰ª∂Ôºå‰ΩøÁî®Êú¨Âú∞ËØªÂèñ")
            guard let fileExtension = fileExtension else {
                let error = BookingDataError.missingConfiguration("Áº∫Â∞ëÊñá‰ª∂Êâ©Â±ïÂêç")
                ErrorHandler.logError(error, context: "AsyncFileReader.readFile", enableVerboseLogging: enableVerboseLogging)
                throw error
            }
            return try await readLocalFile(fileName: source, fileExtension: fileExtension)
        }
    }
    
    // MARK: - ÁßÅÊúâÊñπÊ≥ï
    
    /// ‰ΩøÁî®FileHandleÂºÇÊ≠•ËØªÂèñÊú¨Âú∞Êñá‰ª∂
    /// - Parameter url: Êñá‰ª∂URL
    /// - Returns: Êñá‰ª∂Êï∞ÊçÆ
    /// - Throws: BookingDataError
    private func readLocalFileWithFileHandle(url: URL) async throws -> Data {
        return try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let fileHandle = try FileHandle(forReadingFrom: url)
                    defer {
                        try? fileHandle.close()
                    }
                    
                    // Ëé∑ÂèñÊñá‰ª∂Â§ßÂ∞è
                    let fileSize = try FileManager.default.attributesOfItem(atPath: url.path)[.size] as? Int64 ?? 0
                    self.log("üìä [AsyncFileReader] Êñá‰ª∂Â§ßÂ∞è: \(fileSize) Â≠óËäÇ")
                    
                    // ÂàÜÂùóËØªÂèñÊñá‰ª∂ÔºàÈÄÇÁî®‰∫éÂ§ßÊñá‰ª∂Ôºâ
                    let chunkSize = 1024 * 1024 // 1MB chunks
                    var data = Data()
                    
                    while true {
                        let chunk = fileHandle.readData(ofLength: chunkSize)
                        if chunk.isEmpty {
                            break
                        }
                        data.append(chunk)
                        
                        // Êõ¥Êñ∞ËøõÂ∫¶ÔºàÂèØÈÄâÔºâ
                        if self.enableVerboseLogging {
                            let progress = Double(data.count) / Double(fileSize) * 100
                            self.log("üìà [AsyncFileReader] ËØªÂèñËøõÂ∫¶: \(String(format: "%.1f", progress))%")
                        }
                    }
                    
                    self.log("‚úÖ [AsyncFileReader] ÊàêÂäüËØªÂèñÊú¨Âú∞Êñá‰ª∂ÔºåÂ§ßÂ∞è: \(data.count) Â≠óËäÇ")
                    continuation.resume(returning: data)
                    
                } catch {
                    let bookingError = ErrorHandler.handleFileSystemError(error, filePath: url.path)
                    self.log("‚ùå [AsyncFileReader] ËØªÂèñÊú¨Âú∞Êñá‰ª∂Â§±Ë¥•: \(bookingError.localizedDescription)")
                    continuation.resume(throwing: bookingError)
                }
            }
        }
    }
    
    /// Êù°‰ª∂Êó•ÂøóËæìÂá∫
    /// - Parameter message: Êó•ÂøóÊ∂àÊÅØ
    private func log(_ message: String) {
        if enableVerboseLogging {
            print(message)
        }
    }
}

// MARK: - È´òÁ∫ßÂºÇÊ≠•Êñá‰ª∂ËØªÂèñÂäüËÉΩ
extension AsyncFileReader {
    
    /// Â∏¶ËøõÂ∫¶ÂõûË∞ÉÁöÑÂºÇÊ≠•Êñá‰ª∂ËØªÂèñ
    /// - Parameters:
    ///   - source: Êñá‰ª∂Ê∫ê
    ///   - fileExtension: Êñá‰ª∂Êâ©Â±ïÂêç
    ///   - timeout: Ë∂ÖÊó∂Êó∂Èó¥
    ///   - progressCallback: ËøõÂ∫¶ÂõûË∞É
    /// - Returns: Êñá‰ª∂Êï∞ÊçÆ
    /// - Throws: BookingDataError
    func readFileWithProgress(
        source: String,
        fileExtension: String? = nil,
        timeout: TimeInterval? = nil,
        progressCallback: @escaping (Double) -> Void
    ) async throws -> Data {
        
        // Ê£ÄÊµãÊòØÂê¶‰∏∫URL
        if let url = URL(string: source), url.scheme != nil {
            return try await retryManager.executeWithRetry(
                { try await self.readRemoteFileWithProgress(url: url, timeout: timeout ?? 30.0, progressCallback: progressCallback) },
                progressCallback: progressCallback
            )
        } else {
            guard let fileExtension = fileExtension else {
                throw BookingDataError.missingConfiguration("Áº∫Â∞ëÊñá‰ª∂Êâ©Â±ïÂêç")
            }
            return try await retryManager.executeWithRetry(
                { try await self.readLocalFileWithProgress(fileName: source, fileExtension: fileExtension, progressCallback: progressCallback) },
                progressCallback: progressCallback
            )
        }
    }
    
    /// Â∏¶ËøõÂ∫¶ÁöÑÊú¨Âú∞Êñá‰ª∂ËØªÂèñ
    private func readLocalFileWithProgress(
        fileName: String,
        fileExtension: String,
        progressCallback: @escaping (Double) -> Void
    ) async throws -> Data {
        guard let fileURL = Bundle.main.url(forResource: fileName, withExtension: fileExtension) else {
            throw BookingDataError.fileNotFound("Bundle‰∏≠Êâæ‰∏çÂà∞Êñá‰ª∂: \(fileName).\(fileExtension)")
        }
        
        return try await withCheckedThrowingContinuation { continuation in
            DispatchQueue.global(qos: .userInitiated).async {
                do {
                    let fileHandle = try FileHandle(forReadingFrom: fileURL)
                    defer {
                        try? fileHandle.close()
                    }
                    
                    let fileSize = try FileManager.default.attributesOfItem(atPath: fileURL.path)[.size] as? Int64 ?? 0
                    var data = Data()
                    let chunkSize = 1024 * 64 // 64KB chunks for better progress updates
                    
                    while true {
                        let chunk = fileHandle.readData(ofLength: chunkSize)
                        if chunk.isEmpty {
                            break
                        }
                        data.append(chunk)
                        
                        let progress = Double(data.count) / Double(fileSize)
                        DispatchQueue.main.async {
                            progressCallback(progress)
                        }
                    }
                    
                    continuation.resume(returning: data)
                    
                } catch {
                    let bookingError = ErrorHandler.handleFileSystemError(error, filePath: fileURL.path)
                    continuation.resume(throwing: bookingError)
                }
            }
        }
    }
    
    /// Â∏¶ËøõÂ∫¶ÁöÑËøúÁ®ãÊñá‰ª∂ËØªÂèñ
    private func readRemoteFileWithProgress(
        url: URL,
        timeout: TimeInterval,
        progressCallback: @escaping (Double) -> Void
    ) async throws -> Data {
        var request = URLRequest(url: url)
        request.timeoutInterval = timeout
        
        let (data, response) = try await urlSession.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse,
              httpResponse.statusCode == 200 else {
            if let httpResponse = response as? HTTPURLResponse {
                throw ErrorHandler.handleHTTPStatusCode(httpResponse.statusCode, url: url.absoluteString)
            } else {
                throw BookingDataError.networkError("Êó†ÊïàÁöÑHTTPÂìçÂ∫î")
            }
        }
        
        // Ê®°ÊãüËøõÂ∫¶Êõ¥Êñ∞ÔºàÂÆûÈôÖÂ∫îÁî®‰∏≠ÂèØËÉΩÈúÄË¶ÅÊµÅÂºè‰∏ãËΩΩÔºâ
        DispatchQueue.main.async {
            progressCallback(1.0)
        }
        
        return data
    }
    
    /// ÊâπÈáèÂºÇÊ≠•ËØªÂèñÂ§ö‰∏™Êñá‰ª∂
    /// - Parameter sources: Êñá‰ª∂Ê∫êÊï∞ÁªÑ
    /// - Returns: Êñá‰ª∂Êï∞ÊçÆÊï∞ÁªÑ
    /// - Throws: BookingDataError
    func readMultipleFiles(sources: [(source: String, fileExtension: String?, timeout: TimeInterval?)]) async throws -> [Data] {
        log("üìö [AsyncFileReader] ÂºÄÂßãÊâπÈáèËØªÂèñ \(sources.count) ‰∏™Êñá‰ª∂")
        
        return try await withThrowingTaskGroup(of: Data.self) { group in
            var results: [Data] = []
            
            // Ê∑ªÂä†ÊâÄÊúâËØªÂèñ‰ªªÂä°
            for source in sources {
                group.addTask {
                    try await self.readFile(
                        source: source.source,
                        fileExtension: source.fileExtension,
                        timeout: source.timeout
                    )
                }
            }
            
            // Êî∂ÈõÜÁªìÊûú
            for try await data in group {
                results.append(data)
            }
            
            log("‚úÖ [AsyncFileReader] ÊâπÈáèËØªÂèñÂÆåÊàêÔºåÊàêÂäüËØªÂèñ \(results.count) ‰∏™Êñá‰ª∂")
            return results
        }
    }
    
    /// ÂèñÊ∂àÊâÄÊúâËøõË°å‰∏≠ÁöÑËØ∑Ê±Ç
    func cancelAllRequests() {
        urlSession.invalidateAndCancel()
        log("üõë [AsyncFileReader] Â∑≤ÂèñÊ∂àÊâÄÊúâÁΩëÁªúËØ∑Ê±Ç")
    }
    
    // MARK: - ÂéãÁº©Êñá‰ª∂ËØªÂèñÊñπÊ≥ï
    
    /// ÂºÇÊ≠•ËØªÂèñÂéãÁº©Êñá‰ª∂
    /// - Parameters:
    ///   - fileName: Êñá‰ª∂ÂêçÔºà‰∏çÂåÖÂê´Êâ©Â±ïÂêçÔºâ
    ///   - fileExtension: Êñá‰ª∂Êâ©Â±ïÂêç
    ///   - bundle: BundleÂÆû‰æã
    ///   - autoDecompress: ÊòØÂê¶Ëá™Âä®Ëß£ÂéãÁº©
    /// - Returns: Êñá‰ª∂Êï∞ÊçÆÔºàÂ¶ÇÊûúautoDecompress‰∏∫trueÔºåËøîÂõûËß£ÂéãÁº©ÂêéÁöÑÊï∞ÊçÆÔºâ
    /// - Throws: BookingDataError
    func readCompressedFile(
        fileName: String,
        fileExtension: String,
        bundle: Bundle,
        autoDecompress: Bool
    ) async throws -> Data {
        log("üì¶ [AsyncFileReader] ÂºÄÂßãËØªÂèñÂéãÁº©Êñá‰ª∂: \(fileName).\(fileExtension)")
        
        // È¶ñÂÖàËØªÂèñÂéüÂßãÊñá‰ª∂Êï∞ÊçÆ
        let rawData = try await readLocalFile(fileName: fileName, fileExtension: fileExtension, bundle: bundle)
        
        // Ê£ÄÊµãÂéãÁº©Ê†ºÂºè
        guard let compressionInfo = compressionManager.detectCompressionFormat(from: rawData) else {
            log("‚ö†Ô∏è [AsyncFileReader] Êñá‰ª∂‰∏çÊòØÂéãÁº©Ê†ºÂºèÔºåËøîÂõûÂéüÂßãÊï∞ÊçÆ")
            return rawData
        }
        
        log("üîç [AsyncFileReader] Ê£ÄÊµãÂà∞ÂéãÁº©Ê†ºÂºè: \(compressionInfo.format.displayName)")
        
        if autoDecompress {
            log("üîÑ [AsyncFileReader] ÂºÄÂßãËá™Âä®Ëß£ÂéãÁº©...")
            let decompressedData = try await compressionManager.decompress(data: rawData, format: compressionInfo.format)
            log("‚úÖ [AsyncFileReader] Ëß£ÂéãÁº©ÂÆåÊàêÔºåÂéüÂßãÂ§ßÂ∞è: \(rawData.count) Â≠óËäÇÔºåËß£ÂéãÁº©ÂêéÂ§ßÂ∞è: \(decompressedData.count) Â≠óËäÇ")
            return decompressedData
        } else {
            log("üì¶ [AsyncFileReader] ËøîÂõûÂéãÁº©Êï∞ÊçÆÔºåÂ§ßÂ∞è: \(rawData.count) Â≠óËäÇ")
            return rawData
        }
    }
    
    /// ÂºÇÊ≠•ËØªÂèñËøúÁ®ãÂéãÁº©Êñá‰ª∂
    /// - Parameters:
    ///   - url: ËøúÁ®ãÊñá‰ª∂URL
    ///   - timeout: ËØ∑Ê±ÇË∂ÖÊó∂Êó∂Èó¥
    ///   - autoDecompress: ÊòØÂê¶Ëá™Âä®Ëß£ÂéãÁº©
    /// - Returns: Êñá‰ª∂Êï∞ÊçÆÔºàÂ¶ÇÊûúautoDecompress‰∏∫trueÔºåËøîÂõûËß£ÂéãÁº©ÂêéÁöÑÊï∞ÊçÆÔºâ
    /// - Throws: BookingDataError
    func readRemoteCompressedFile(
        url: URL,
        timeout: TimeInterval,
        autoDecompress: Bool
    ) async throws -> Data {
        log("üåê [AsyncFileReader] ÂºÄÂßãËØªÂèñËøúÁ®ãÂéãÁº©Êñá‰ª∂: \(url.absoluteString)")
        
        // È¶ñÂÖàËØªÂèñÂéüÂßãÊñá‰ª∂Êï∞ÊçÆ
        let rawData = try await readRemoteFile(url: url, timeout: timeout)
        
        // Ê£ÄÊµãÂéãÁº©Ê†ºÂºè
        guard let compressionInfo = compressionManager.detectCompressionFormat(from: rawData) else {
            log("‚ö†Ô∏è [AsyncFileReader] ËøúÁ®ãÊñá‰ª∂‰∏çÊòØÂéãÁº©Ê†ºÂºèÔºåËøîÂõûÂéüÂßãÊï∞ÊçÆ")
            return rawData
        }
        
        log("üîç [AsyncFileReader] Ê£ÄÊµãÂà∞ËøúÁ®ãÊñá‰ª∂ÂéãÁº©Ê†ºÂºè: \(compressionInfo.format.displayName)")
        
        if autoDecompress {
            log("üîÑ [AsyncFileReader] ÂºÄÂßãËá™Âä®Ëß£ÂéãÁº©ËøúÁ®ãÊñá‰ª∂...")
            let decompressedData = try await compressionManager.decompress(data: rawData, format: compressionInfo.format)
            log("‚úÖ [AsyncFileReader] ËøúÁ®ãÊñá‰ª∂Ëß£ÂéãÁº©ÂÆåÊàêÔºåÂéüÂßãÂ§ßÂ∞è: \(rawData.count) Â≠óËäÇÔºåËß£ÂéãÁº©ÂêéÂ§ßÂ∞è: \(decompressedData.count) Â≠óËäÇ")
            return decompressedData
        } else {
            log("üì¶ [AsyncFileReader] ËøîÂõûËøúÁ®ãÂéãÁº©Êï∞ÊçÆÔºåÂ§ßÂ∞è: \(rawData.count) Â≠óËäÇ")
            return rawData
        }
    }
    
    /// Ê£ÄÊµãÊñá‰ª∂ÊòØÂê¶‰∏∫ÂéãÁº©Ê†ºÂºè
    /// - Parameter data: Êñá‰ª∂Êï∞ÊçÆ
    /// - Returns: ÂéãÁº©‰ø°ÊÅØÔºåÂ¶ÇÊûú‰∏çÊòØÂéãÁº©Ê†ºÂºèÂàôËøîÂõûnil
    func detectCompressionFormat(from data: Data) -> CompressionInfo? {
        return compressionManager.detectCompressionFormat(from: data)
    }
}

// MARK: - Êñá‰ª∂ËØªÂèñÂ∑•ÂéÇ
enum AsyncFileReaderFactory {
    /// ÂàõÂª∫ÈªòËÆ§ÁöÑÂºÇÊ≠•Êñá‰ª∂ËØªÂèñÂô®
    /// - Parameters:
    ///   - enableVerboseLogging: ÊòØÂê¶ÂêØÁî®ËØ¶ÁªÜÊó•Âøó
    ///   - retryConfiguration: ÈáçËØïÈÖçÁΩÆ
    ///   - compressionManager: ÂéãÁº©ÁÆ°ÁêÜÂô®
    /// - Returns: AsyncFileReaderÂÆû‰æã
    static func createDefault(enableVerboseLogging: Bool = true, retryConfiguration: RetryConfiguration = .default, compressionManager: CompressionManagerProtocol? = nil) -> AsyncFileReader {
        return AsyncFileReader(enableVerboseLogging: enableVerboseLogging, retryConfiguration: retryConfiguration, compressionManager: compressionManager)
    }
    
    /// ÂàõÂª∫Áî®‰∫éÊµãËØïÁöÑÂºÇÊ≠•Êñá‰ª∂ËØªÂèñÂô®
    /// - Parameters:
    ///   - enableVerboseLogging: ÊòØÂê¶ÂêØÁî®ËØ¶ÁªÜÊó•Âøó
    ///   - retryConfiguration: ÈáçËØïÈÖçÁΩÆ
    ///   - compressionManager: ÂéãÁº©ÁÆ°ÁêÜÂô®
    /// - Returns: AsyncFileReaderÂÆû‰æã
    static func createForTesting(enableVerboseLogging: Bool = true, retryConfiguration: RetryConfiguration = .fast, compressionManager: CompressionManagerProtocol? = nil) -> AsyncFileReader {
        return AsyncFileReader(enableVerboseLogging: enableVerboseLogging, retryConfiguration: retryConfiguration, compressionManager: compressionManager)
    }
    
    /// ÂàõÂª∫Áî®‰∫éÁîü‰∫ßÁéØÂ¢ÉÁöÑÂºÇÊ≠•Êñá‰ª∂ËØªÂèñÂô®
    /// - Parameters:
    ///   - enableVerboseLogging: ÊòØÂê¶ÂêØÁî®ËØ¶ÁªÜÊó•Âøó
    ///   - retryConfiguration: ÈáçËØïÈÖçÁΩÆ
    ///   - compressionManager: ÂéãÁº©ÁÆ°ÁêÜÂô®
    /// - Returns: AsyncFileReaderÂÆû‰æã
    static func createForProduction(enableVerboseLogging: Bool = false, retryConfiguration: RetryConfiguration = .conservative, compressionManager: CompressionManagerProtocol? = nil) -> AsyncFileReader {
        return AsyncFileReader(enableVerboseLogging: enableVerboseLogging, retryConfiguration: retryConfiguration, compressionManager: compressionManager)
    }
    
    /// ÂàõÂª∫È´òÂèØÈù†ÊÄßÂºÇÊ≠•Êñá‰ª∂ËØªÂèñÂô®
    /// - Parameters:
    ///   - enableVerboseLogging: ÊòØÂê¶ÂêØÁî®ËØ¶ÁªÜÊó•Âøó
    ///   - compressionManager: ÂéãÁº©ÁÆ°ÁêÜÂô®
    /// - Returns: AsyncFileReaderÂÆû‰æã
    static func createHighReliability(enableVerboseLogging: Bool = true, compressionManager: CompressionManagerProtocol? = nil) -> AsyncFileReader {
        let adaptiveConfig = RetryConfiguration(
            maxAttempts: 5,
            baseDelay: 1.0,
            maxDelay: 60.0,
            strategy: AdaptiveRetryStrategy(),
            enabled: true
        )
        return AsyncFileReader(enableVerboseLogging: enableVerboseLogging, retryConfiguration: adaptiveConfig, compressionManager: compressionManager)
    }
    
    /// ÂàõÂª∫ÊîØÊåÅÂéãÁº©ÁöÑÂºÇÊ≠•Êñá‰ª∂ËØªÂèñÂô®
    /// - Parameters:
    ///   - enableVerboseLogging: ÊòØÂê¶ÂêØÁî®ËØ¶ÁªÜÊó•Âøó
    ///   - retryConfiguration: ÈáçËØïÈÖçÁΩÆ
    /// - Returns: AsyncFileReaderÂÆû‰æã
    static func createWithCompression(enableVerboseLogging: Bool = true, retryConfiguration: RetryConfiguration = .default) -> AsyncFileReader {
        let compressionManager = CompressionManagerFactory.createDefault(enableVerboseLogging: enableVerboseLogging)
        return AsyncFileReader(enableVerboseLogging: enableVerboseLogging, retryConfiguration: retryConfiguration, compressionManager: compressionManager)
    }
}
